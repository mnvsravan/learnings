# The difference between sets and dictionaries is that sets are unordered collections of unique elements, while dictionaries are ordered collections of key-value pairs. In a set, you can only store unique values, and the order of the elements is not guaranteed. In contrast, a dictionary allows you to store key-value pairs, where each key is unique and maps to a specific value. The order of the key-value pairs in a dictionary is preserved as of Python 3.7 and later versions.
# we cannot change the elements of a set, but we can add or remove elements from a set. In contrast, we can change the values of a dictionary by updating the value associated with a specific key. Additionally, sets do not have keys, while dictionaries use keys to access their values.
# sets are defined using curly braces {} or the set() constructor. For example, you can create a set of numbers like this: my_set = {1, 2, 3} or my_set = set([1, 2, 3]). Sets can contain any immutable data type, such as integers, floats, strings, and tuples. However, sets cannot contain mutable data types like lists or dictionaries.
#Set is a collection of non-repetitive elements.
setxx={1,2,3,4,2,5,6,7,8,9,10} # this will create a set called set that contains the values 1, 2, 3, 4, 5, 6, 7, 8, 9, and 10. The duplicate value 2 will be ignored since sets only store unique elements.
print(setxx) # this will print the set to the console. The output will be {1, 2, 3, 4, 5, 6, 7, 8, 9, 10}, which shows that the duplicate value 2 has been removed from the set. Note that the order of the elements in a set is not guaranteed and may vary each time you run the code.
set1=(1,2,3,4,5,5,5,5,5) 
print(set1) # this will print the tuple set1 to the console. The output will be (1, 2, 3, 4, 5, 5, 5, 5, 5), which shows that the duplicate value 5 is included in the tuple since tuples can contain duplicate elements. Note that the order of the elements in a tuple is preserved, so the output will always be the same when you run the code.
#empty set
set_2=set() # this will create an empty set called set2 using the set() constructor. Note that using empty curly braces {} will create an empty dictionary, not an empty set, so it's important to use the set() constructor when creating an empty set.
print(set_2) # this will print the empty set set2 to the console. The output will be set(), which indicates that the set is empty. Note that the output may vary depending on the version of Python you are using, but it will always indicate that the set is empty.
my_set = {1, 2, 3, 4, 5} # this will create a set called my_set that contains the values 1, 2, 3, 4, and 5.
my_set.add(6) # this will add the value 6 to the set my_set using the add() method. If the value 6 is already present in the set, it will not be added again since sets only store unique elements.
print(my_set) # this will print the set my_set to the console. The output will be {1, 2, 3, 4, 5, 6}, which shows that the value 6 has been added to the set. Note that the order of the elements in a set is not guaranteed and may vary each time you run the code.



# functions in sets
my_set5 = {1, 2, 3, 4, 5} # this will create a set called my_set that contains the values 1, 2, 3, 4, and 5.
print(len(my_set5)) # this will print the number of elements in the set my_set to the console. The output will be 5, which indicates that there are 5 unique elements in the set. Note that the len() function counts the number of unique elements in a set, so if there were duplicate values in the set, they would not be counted multiple times.
my_set6 = {1, 2, 3, 4, 5} # this will create a set called my_set that contains the values 1, 2, 3, 4, and 5.
print(3 in my_set6) # this will check if the value 3 is present in the set my_set and print the result to the console. The output will be True, which indicates that the value 3 is indeed present in the set. If you were to check for a value that is not in the set, such as 6, the output would be False.
# sets are unordered collections of unique elements, which means that the order of the elements in a set is not guaranteed and may vary each time you run the code. When you print a set, the elements may appear in a different order than how they were added to the set. This is because sets are implemented as hash tables, which do not maintain any specific order for the elements. Therefore, when you print a set, the output may show the elements in a different order than how they were added to the set.
# sets are mutable, which means that you can add or remove elements from a set after it has been created. However, the elements themselves must be immutable, which means that they cannot be changed after they have been added to the set. For example, you can add a string to a set, but you cannot change the characters in that string once it has been added to the set. Similarly, you can add a tuple to a set, but you cannot change the values in that tuple once it has been added to the set. This is because sets rely on the immutability of their elements to ensure that they can be hashed and stored efficiently
print(my_set5.remove(3)) # this will remove the value 3 from the set my_set using the remove() method. If the value 3 is not present in the set, it will raise a KeyError. Note that the remove() method modifies the original set and does not return a new set.
print(my_set5) # this will print the set my_set to the console after the value 3 has been removed. The output will be {1, 2, 4, 5}, which shows that the value 3 has been successfully removed from the set. Note that the order of the elements in a set is not guaranteed and may vary each time you run the code.
print(my_set5.discard(4)) # this will remove the value 4 from the set my_set using the discard() method. If the value 4 is not present in the set, it will not raise an error and will simply do nothing. Note that the discard() method modifies the original set and does not return a new set.
print(my_set5) # this will print the set my_set to the console after the value
print(my_set6.pop()) # this will remove and return an arbitrary element from the set my_set using the pop() method. Since sets are unordered, there is no guarantee which element will be removed. If the set is empty, it will raise a KeyError. Note that the pop() method modifies the original set and returns the removed element.
print(my_set6) # this will print the set my_set to the console after an arbitrary
clear=my_set6.clear() # this will remove all elements from the set my_set using the clear() method. After this operation, the set will be empty. Note that the clear() method modifies the original set and does not return a new set.
print(my_set6) # this will print the set my_set to the console after all elements have been removed. The output will be set(), which indicates that the set is now empty. Note that the output may vary depending on the version of Python you are using, but it will always indicate that the set is empty.
# more advanced functions in sets
set_a = {1, 2, 3, 4, 5} #
set_b = {4, 5, 6, 7, 8} # this will create a set called set_b that contains the values 4, 5, 6, 7, and 8.
intersection = set_a.intersection(set_b) # this will calculate the intersection of set_a and set_b using the intersection() method. The intersection of two sets is a new set that contains only the elements that are present in both sets. In this case, the intersection will be {4, 5}, since those are the only values that are present in both set_a and set_b.
print(intersection) # this will print the intersection of set_a and set_b to the console
union = set_a.union(set_b) # this will calculate the union of set_a and set_b using the union() method. The union of two sets is a new set that contains all the unique elements from both sets. In this case, the union will be {1, 2, 3, 4, 5, 6, 7, 8}, since those are all the unique values that are present in either set_a or set_b.
print(union) # this will print the union of set_a and set_b to the console
difference = set_a.difference(set_b) # this will calculate the difference of set_a and set_b using the difference() method. The difference of two sets is a new set that contains only the elements that are present in the first set but not in the second set. In this case, the difference will be {1, 2, 3}, since those are the values that are present in set_a but not in set_b.
print(difference) # this will print the difference of set_a and set_b to the console
symmetric_difference = set_a.symmetric_difference(set_b) # this will calculate the symmetric difference of set_a and set_b using the symmetric_difference() method. The symmetric difference of two sets is a new set that contains only the elements that are present in either set_a or set_b, but not in both sets. In this case, the symmetric difference will be {1, 2, 3, 6, 7, 8}, since those are the values that are present in either set_a or set_b but not in both sets.
print(symmetric_difference) # this will print the symmetric difference of set_a and set_b to the console
# even more advanced functions in sets
set_c = {1, 2, 3} # this will create a set called set_c that contains the values 1, 2, and 3.
set_d = {1, 2, 3, 4, 5} # this will create a set called set_d that contains the values 1, 2, 3, 4, and 5.
print(set_c.issubset(set_d)) # this will check if set_c is a subset of set_d using the issubset() method. A set A is considered a subset of another set B if all elements of A are also present in B. In this case, the output will be True, since all elements of set_c (1, 2, and 3) are indeed present in set_d.
print(set_d.issuperset(set_c)) # this will check if set_d is a superset of set_c using the issuperset() method. A set A is considered a superset of another set B if all elements of B are also present in A. In this case, the output will be True, since all elements of set_c (1, 2, and 3) are indeed present in set_d, making set_d a superset of set_c.
#even more advanced functions in sets
set_e = {1, 2, 3} # this will create a set called set_e that contains the values 1, 2, and 3.
set_f = {4, 5, 6} # this will create a set called set_f that contains the values 4, 5, and 6.
print(set_e.isdisjoint(set_f)) # this will check if set_e and set_f are disjoint sets using the isdisjoint() method. Two sets are considered disjoint if they have no elements in common. In this case, the output will be True, since there are no common elements between set_e (1, 2, and 3) and set_f (4, 5, and 6), making them disjoint sets.
# frozen sets are immutable sets, which means that once a frozenset is created, its elements cannot be changed. This makes frozensets useful for situations where you want to create a set that should not be modified after it has been created. Frozensets are defined using the frozenset() constructor. For example, you can create a frozenset of numbers like this: my_frozenset = frozenset([1, 2, 3]). Frozensets can contain any immutable data type, such as integers, floats, strings, and tuples. However, frozensets cannot contain mutable data types like lists or dictionaries.
my_frozenset = frozenset([1, 2, 3]) # this will create a frozenset called my_frozenset that contains the values 1, 2, and 3. Note that the input to the frozenset() constructor is a list, which is converted into a frozenset.
print(my_frozenset) # this will print the frozenset my_frozenset to the console. The output will be frozenset({1, 2, 3}), which indicates that the frozenset contains the values 1, 2, and 3. Note that the order of the elements in a frozenset is not guaranteed and may vary each time you run the code.
